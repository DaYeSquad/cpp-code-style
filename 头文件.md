# 头文件

通常每一个 `.cc`文件都有一个对应的 `.h`文件. 也有一些常见的例外, 比如单元测试或者只包含 `main()` 函数的小 `.cc `文件.

正确使用头文件可令代码在可读性、文件大小和性能上大为改观.

下面的规则将引导你规避使用头文件时的各种陷阱.

## Self-contained 头文件

头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 .h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 .inc 结尾。不允许分离出 -inl.h 头文件的做法.

所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 #define 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.

不过有一个例外, 即一个文件并不是 self-contained 的，而是作为文本插入到代码某处. 或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 .inc 文件扩展名.

如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 -inl.h 文件里（译者注：过去该规范曾提倡把定义放到 -inl.h 里过）。

有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。

## #define 保护

所有的头文件都应有 #define 保护来避免头文件被多重包含, 命名格式应为: `<PROJECT>_<PATH>_<FILE>_H_`

为了保证唯一性, 头文件的命名应当基于项目源码树的完整路径. 例如, 工程 `foo` 下的文件 `foo/src/bar/baz.h` 的可按如下方式保护:

```
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```

## 前置声明

尽量避免使用前置声明. 按需 `#include` 头文件即可.

*定义:*

「前置声明」(forward declaration) 是指类, 函数和模板的纯粹声明, 没有伴随着其定义.

*优点:*

- 前置声明可以减少编译时间, 多余的 #include 会迫使编译器展开更多的文件，处理更多的输入.
- 置声明可以减少不必要的重新编译的时间。`#include` 让代码因为头文件中的无关改动而被多次重新编译.

*缺点:*

- 前置声明隐藏了依赖关系, 当头文件变化时, 前置声明允许用户代码跳过必要的重新编译过程.
- 前置声明可能会被库的后续更改所破坏. 前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参, 或是迁移到新的命名空间等.
- 前置声明来自命名空间 std:: 的 symbol 时, 其行为未定义.
- 很难判断什么时候该用前置声明, 什么时候该用 `#include`, 极端情况下, 用前置声明代替 `#includes` 甚至会暗暗地改变代码的含义: 
```
      // b.h:
      struct B {};
      struct D : B {};

      // good_user.cc:
      #include "b.h"
      void f(B*);
      void f(void*);
      void test(D* x) { f(x); }  // calls f(B*)
```
如果 `#include` 被 `B` 和 `D` 的前置声明代替, `test()` 就会调用 `f(void*)`.

- 前置声明了不少来自头文件的 symbol 时, 就会比单单一行的 `#include` 更冗长.
- 为了能前置声明而重构代码 (比如使用指针成员替代对象成员), 会让代码变得更慢更复杂.

*结论:*

- 尽量避免前置声明那些定义在其他项目中的实体.
- 调用头文件中声明的函数时, 总是使用 `#include`.
- 调用类模板时, 优先使用 `#include`.

## 内联函数

只有当函数很小 (10行及以内) 时才将其定义为内联函数.

*定义:*

当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

*优点:*

内联函数很小的时候, 可以生成更加高效的目标代码. 对于存取函数和其他比较短的, 性能关键的函数, 鼓励使用内联.

*缺点:*

过度使用内联函数会让程序变得缓慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但是内联一个很长的函数会让代码量疯长. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快.

*结论:*

一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数会隐式调用类成员和父类的析构函数, 导致其代码量比看起来要长很多.

另一个实用的经验准则: 内联那些包含循环或 `swtich` 语句的函数往往得不偿失 (除非在大多数情况下这些循环或者 `swtich` 语句不会被执行).

即使函数被声明为内联函数, 也不一定就会被编译器内联, 这点很重要. 比如虚函数或者递归函数就不会被正常内联. 通常递归函数不应该声明为内联函数. 虚函数内联的主要原因是想把函数体放在类定义内, 为了方便, 或者当成是文档描述其行为, 比如存取函数.

## `包含的命名和顺序`

使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 `.h`, 你的项目内的 `.h`.

项目内头文件应按照项目源代码目录树结构排列m 避免使用 `UNIX` 特殊的快捷目录 `.` (当前路径) 和 `..` (父路径). 比如 `google-awesome-project/src/base/logging.h` 应该按如下方式包含:
```
#include "base/logging.h"
```

`dir/foo.cc` 或 `dir/foo_test.cc` 是用来实现或测试 `dir2/foo2.h` 的功能, `foo.cc` 中包含的头文件的次序如下:
1. `dir2/foo2.h`
2. C 系统文件
3. C++系统文件
4. 其他库的 `.h` 文件
5. 你的项目内的 `.h` 文件

这种优先的顺序排序保证当 `dir2/foo2.h` 少包含了某些重要的库时, `dir/foo.cc` 或 `dir/foo_test.cc` 的构建会立刻终止. 这一条规则保证维护这些文件的人首先看到构建中止的消息, 而不是维护其他包的人.

`dir/foo.cc` 和 `dir2/foo2.h` 通常位于同一目录下 (如 `base/basictypes_unittest.cc` 和 `base/basictypes.h`), 但也可以放在不同目录下.

在每个部分都应按照字母顺序对头文件包含进行排序. 较老的代码可不符合这条规则, 要在方便的时候改正它们.

你依赖的 symbols 被哪些头文件所定义, 就应该包含哪些头文件, 前置声明的情况除外. 如果你要用到 `bar.h` 中的某个 symbol, 哪怕所包含的 `foo.h` 已经包含了 `bar.h`, 还是需要包含 `bar.h` , 除非 `foo.h` 明确说明它会自动提`bar.h` 中的 symbol. 不过, 凡是 `.cc` 文件所对应的相关头文件已经包含过的, 就不用再重复包含进其 `.cc` 文件里了 (比如 `foo.cc` 只需要包含 `foo.h`).

举例来说, `google-awesome-project/src/foo/internal/fooserver.cc` 中的包含可能如下:

```
#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
```

*例外:*

有时, 平台特定 (system-specific) 的代码需要条件包含 (conditional includes), 这些代码可以放到其他包含之后. 当然, 需要保证平台特定的代码短小且独立, 比如:

```
#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
```